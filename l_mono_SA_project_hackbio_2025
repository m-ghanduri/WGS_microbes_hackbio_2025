#!/bin/bash

#this script assumes that all of the files were downloaded and checked properly. I have another script to actually go through and double check that

#the first thing to do, is to store the ls for the folder "fastq_files" into "dir_array" array, where each file name is stored as an element
#the most optimal thing to do is to go by increasing size, but that would be an issue with ls. Instead, ls automatically outputs the file names alphanumerically
#this means, that the array will look like this: [[sample1_1],[sample1_2],[sample2_1],[sample2_2]...[samplen_1],[samplen_2]]
#array_length is then computed using wc -w on "dir_array"
#the for loop is designed to filter through "dir_array" by acting only on even element indexes which by design will always index the first file for a sample pair
#we do this by skipping a cycle if the modulo of our index is equal to 1
#after that is completed, we can start working with pairs of samples by calling them via their sample names which are substrings of the element names

dir_array=($(ls fastq_files))
array_length=$( echo "${dir_array[@]}" | wc -w)
for ((z=0;z<="$array_length";z++)); do
	if (( $z%2 == 1 )); then
		continue
	fi
	let j=$z+1
	file1="${dir_array[$z]}" #this stores the first file from a sample pair of files to file1
	echo "$file1"
	file2="${dir_array[$j]}" #this stores the second file from a sample pair of files to file2
	echo "$file2"
	genome_sample_number="${file1:0:11}" #this refers to the sample number and title of the sample by substringing the first 12 characters from the file names
	echo "$genome_sample_number"
	## continue what you want to do here:

	echo "trimming time!"
	#trim and do qc using fastp and then output it into the trimmed files
	fastp -i fastq_files/"$file1" -I fastq_files/"$file2" \
	-o trimmed/"${file1:0:-9}".trim.fastq.gz \
	-O trimmed/"${file2:0:-9}".trim.fastq.gz

	echo "trim complete!"
	echo "time to build the genome!"
	#do fastqc on both of those files
	#mkdir -p qc
	#fastqc trimmed/"$file1".* -O qc/ && fastqc trimmed/"$file2".* -O qc/

	#make the assembly folder and output the assembly using spades there!
	#after proof of function, we can then try piping it
	mkdir -p "$genome_sample_number"_assembly
	spades.py -1 trimmed/"${file1:0:-9}".trim.fastq.gz \
	-2 trimmed/"${file2:0:-9}".trim.fastq.gz --phred-offset 33 \
	--threads 24 -o "$genome_sample_number"_assembly/

	#remove the temp files
	#rm -rf trimmed

	#get a random 300 bp string and then blast it!
	#here we use mapfile to store the contig fasta into an array which is delemited using the '>' symbol
	mapfile -d \> contig_array \
	< "$genome_sample_number""_assembly/contigs.fasta"

	contig_length=$(echo "${contig_array[1]}" | wc -c) #this is the approximate length of the first and longest contig; we use wc -c for the first element of the array
	random_base=$(shuf -i 100-"$contig_length" -n 1) #this is a random base from 100 to the length of the first contig

	first_element="${contig_array[1]}" # this is the first and longest contig, called as the first element of the array
	first_element_substring=${first_element:$random_base:300} #the second number is the length, while the first number is the offset location
	blast_query=$(echo $first_element_substring | tr -d ' ' )

	#now I have to blast it...
	mkdir -p blast_results
	blastn -db nt -query <(echo "$blast_query") -remote \
	-max_target_seqs 10 \
	-out blast_results/"$genome_sample_number"_blast_results.out #this gives the top 10 matches and searches online through the NCBI -nt database

	#use abricate to annotate through our contigs fasta file and identify AMR and virulence factor genes

	#get my AMR genes!
	mkdir -p AMR
	abricate "$genome_sample_number"_assembly/contigs.fasta > AMR/"$genome_sample_number"_amr_tab.tab

	#get my virulence factors/toxins!
	mkdir -p VFs
	abricate --db vfdb "$genome_sample_number"_assembly/contigs.fasta > VFs/"$genome_sample_number"_VFs_tab.tab	
done
